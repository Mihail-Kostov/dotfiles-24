or [customizing](https://www.reddit.com/r/unixporn/wiki/index) one's 
computer desktop is more than just changing a desktop wallpaper or GUI 
theme for *nix users, though, it often begins with such.

Ricing commonly includes matching the terminal colours and desktop 
information panels to the desktop background image or colour, choosing 
default fonts, mouse pointer styles, etc. Many [desktop environments or 
DE's](https://wiki.archlinux.org/index.php/Desktop_environment) provide 
utilities for tweaking these parameters.

However, if you like to change your desktop background with regularity, 
the effort can be prohibitively time consuming. That is where some 
scripting rules can assist one's enjoyment of the computer screen we 
stare at all day.

## design

i use tiling window managers exclusively, of which [bspwm][?] and 
[herbstluftwm][?] have been written about extensively on this site. 
Window border colour is easily configured on the fly with these window 
managers through shell commands.

The other notable desktop components of my configuration are the conky 
system information panel and status bar which are themed in a consistent 
fashion through scripts.

Various applications have been written to configure the *.Xresources* 
file terminal colours based on the colour palette of the desktop 
background image. These work (IMO) with varying degrees of success. As 
a coder, I find the narrow terminal colour range that can often be 
generated personally inadequate for source code editing. For this, 
I prefer my own persistent set of terminal colours. YMMV.

Background wallpapers offer interesting textures but I find that 
blurring yields the best results for distraction free work. Wandering 
eyes can be attracted to beautiful images. Herbstluftwm classically 
installs with a default eye burning lime green solid background. That is 
quickly changed or discarded in favour of wallpapers. In that spirit, 
however, I discovered that random  solid background colours generated 
with..

`randcolor() {`
`^  echo "$(od -An -N3 -x /dev/random | sed -e 's/ 00//' -e 's/ //')"`
`}`

[ljust]are quite palatable with my ricing algorithms. And introduce 
a pleasant boot up session surprise.

## monochromatic

colour shades are applied via scripts to the conky panel and status bar. 
This allows allow automatic generation of textual and graphical elements 
for solid background colours and manual generation for background 
images. For the latter, the script is run with a suitable colour which 
can be selected off the image with a colour picker.

Scraping colours from a hexadecimal colour site eases selecting a set of usable colours..

`palette() {`
`^  curl --silent -L "https://www.colorcodehex.com/$1/"`
`}`
`^ `
`hexgen() {`
`^  default_color=$1`
`^  hex=$(palette $default_color)`
`^  color0=$(echo -n "$hex" | grep 'Monochromatic' | cut -d/ -f10)`
`^  color9=$(echo -n "$hex" | grep 'Complementary' | head -1 | cut -d/ -f6)`
`^  colorA=$(echo -n "$hex" | grep 'Monochromatic' | cut -d/ -f6)`
`^  hex=$(palette $color0)`
`^  color6=$(echo -n "$hex" | grep 'Monochromatic' | cut -d/ -f2)`
`^  color7=$(echo -n "$hex" | grep 'Monochromatic' | cut -d/ -f10)`
`^  color8=$color0`
`^  hex=$(palette $color9)`
`^  colorI=$(echo -n "$hex" | grep 'Monochromatic' | cut -d/ -f6)`
`}`

[ljust]which can then be applied to the configuration files and scripts 
for the conky panel and status bar. In this example, colour variables 
corresponding to their conky variable counterparts are assigned the 
scraped colour codes which are subsequently updated in the *.conkyrc* 
file.

Using a script to generate the colour palette provides a consistent 
mechanism or generating or regenerating colour profiles -- or applying 
a new set of colour rules. And applying the complementary colour to 
window borders provides a simple means to distinguish the active window.

## brightness

with dynamically changing background colours and images, text needs to 
be adjusted to have adequate contrast. Determining whether a colour is 
dark or light allows choosing contrasting white or black text..

`brightness() {`
`^  rgb=$(echo "$1" | tr '[a-z]' '[A-Z]')`
`^  R=$(echo "3 k $(echo $rgb | sed -r 's/(..)..../\1/') FF / 255 0.299 * * p" | dc)`
`^  G=$(echo "3 k $(echo $rgb | sed -r 's/..(..)../\1/') FF / 255 0.587 * * p" | dc)`
`^  B=$(echo "3 k $(echo $rgb | sed -r 's/....(..)/\1/') FF / 255 0.114 * * p" | dc)`
`^  [ $(echo "$R $G $B + + 0 k p" | dc | sed 's/\..*//') -lt 128 ]`
`}`

[ljust]This function returns *TRUE* if the passed hex colour code 
*percieved* luminance is dark (i.e. in the range 0 to 127 out of 255).

Visual preferences are highly subjective. The outlined procedure here 
works out pretty well for my setup. As per usual, the dotfiles can be 
found [here](https://github.com/sdothum/dotfiles) where examples of the 
conky panel and status bar update scripts, as well as, desktop 
background management, may be found.

