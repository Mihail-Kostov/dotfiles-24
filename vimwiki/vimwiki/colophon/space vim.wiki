leader keys allow chording command sequences. The two most powerful text 
editors (IMO), [emacs](https://en.wikipedia.org/wiki/Emacs) and 
[Vim](https://en.wikipedia.org/wiki/Emacs), utilize chording keymaps.

Recently, I came across a reference to an active emacs configuration 
called [Spacemacs](http://spacemacs.org/) which uses the **Space** key 
for such. I had considered using the **Space** key as the 
*&lt;leader&gt;* key early on in my configuration of Vim but ultimately 
chose the more commonly used **comma** leader key -- following popular 
convention.

Spacemacs changed all that. As a former user of emacs before slipping to 
the dark side and Vi/Vim decades ago, Spacemacs emulation of Vim via 
*Evil* mode could not be resisted. Ultimately, my initial experience was 
insufficient to convince me to switch back, despite the allure of elisp 
over Vim's native language syntax. (Had *Evil* mode been available back 
when I was a developer, undoubtedly I would have remained an emacs 
user.)

I don't see myself switching off the Vim platform, especially with the 
distraction free plugins I use for writing and the tight integration of 
*vimwiki* with this web site. But Spacemacs did pique my interest in 
using the **Space** key as a leader key which is set with..

`let mapleader = "\<Space>"`

[ljust]Using the thumbs is preferable over the right middle finger for 
the leader key which should come as no surprise for someone who has 
designed his own
[Colemak Shift-DH][colemak shift-dh] layout.

As well, this got me rethinking my key mappings altogether. In 
particular, the use of function keys. 

Function keys are commonly mapped to plugin actions -- an arbitrary 
convention in most cases. Restricting function key assignments to seldom 
used display configuration actions such as distraction free modes, 
statusline configuration, etc., left defining more easily remembered 
leader key
mappings for plugins, using the related Vim mnemonic keys.

So, the [yankring plugin](https://github.com/vim-scripts/YankRing.vim) 
is assigned to **&lt;leader&gt;y** and the [undo tree 
plugin](http://sjl.bitbucket.org/gundo.vim/) is assigned to 
**&lt;leader&gt;u** to complement Vi/Vim's **y** yank and **u** undo 
actions respectively. No more need to remember arbitrary function key 
assignments. Where ever possible, plugins are now *leader* mapped to 
their Vim couterparts. Beautiful.

Using the **Space** key is not without its downsides. Some seemingly 
convenient insert mode mappings had to be dropped because typing 
**Space** *&lt;letter&gt;* is common. This turned out not to be as much 
of an inconvenience as originally thought. Even though many such *imap* 
or insert mode keybinds were defined in my previous Vim configuration, 
it turns out I seldom used such keybinds in practice, instead using the 
*nmap* or normal (command) mode keybind.

More noticeable, however, is the lag time introduced with the **Space** 
leader. While typing, the next word will not be space separated until 
the first letter of the word is struck -- unless you pause long enough 
for the leader check to complete. It doesn't take long to get used to 
this behaviour while looking at the screen but it's there -- touch 
typing at a moderate speed blurs this perception to be all but 
unnoticeable.

There are times this delay can be a nuisance, though, and that is when 
successive **Spaces** are inserted into the document or source code line 
to column align text, because multiple **Space** insertions easily get
ahead of the leader checking. For that case, defining a **Ctrl-Space** 
keymap to insert **Spaces** ignoring the default leader processing check 
does the trick with no lag time penalty..

`inoremap <C-Space> <Space>`

Changing the Vim leader key from the **comma** to the **Space** doesn't 
seem like a big deal. But for me, Vim semantically, it is. It just feels 
so much more correct and natural. Thankyou Spacemacs. YMMV. As per 
usual, my Vim configurations can be found 
[here](https://github.com/sdothum/dotfiles/).

