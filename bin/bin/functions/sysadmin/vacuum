#!/usr/bin/dash
# sdothum - 2016 (c) wtfpl

# Sysadmin
# ▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂

# ......................................................... Housekeeping cleaner

# Usage: vacuum g'enerate | [-f] [clean|CLEAN] [<file>, default=.vacuum]
#
# format: # comment
#         = title
#         ! file         (noconfirm) USE AT YOUR OWN RISK!
#           file         (confirm)
#           file package (noconfirm)
#
#         where, if package exists, do not purge file
#         e.g. ~/.local/share/zathura zathura
#         where, file is relative to current directory by default
#
#         clean == move files to /tmp/vacuum/
#         CLEAN == remove files

usage() {
  echo "usage: $(basename $0) g'enerate | [-f] [clean|CLEAN] [file, default=.$(basename $0)]"
  exit 1
}

# filters (based on 'generated' .vacuum file :-)
folders=$(cat ${0%/*}/.vacuum:protect:folders)
files=$(cat ${0%/*}/.vacuum:protect:files)
configs=$(cat ${0%/*}/.vacuum:protect:configs)

rules=.$(basename $0)
vacuum=/tmp/$(basename $0)
[ -e $vacuum ] || mkdir $vacuum

candidates() {
  # handle spaces in filenames with 'while read' vs 'for loop'
  find $1 -maxdepth 1 | sort --ignore-case >$vacuum:find
  while read path <&3 ;do
    pkg=$(echo ${path##*/} | lowercase | sed -r 's/^\.//; s/(\.conf|rc)$//')
    pacman -Qi "$pkg" >/dev/null 2>&1 && { echo "# $path" >>$rules; } || { ditto "$path"; echo "  $path" >>$rules; }
  done 3< $vacuum:find
}

generate() {
  [ -e $rules ] && { ifno "overwrite $rules" || rm $rules; }
  candidates $HOME
  candidates $HOME/.cache
  candidates $HOME/.config
  for i in $HOME/.local/* ;do candidates $i ;done
  for i in $folders $files $configs ;do comment="$comment; s|^  $i$|# $i|" ;done
  sed -i "s|$HOME/||; \|$HOME|d $comment" $rules
  notify "$rules" 'Backup $HOME and review before proceeding!!'
}

while [ $1 ] ;do
  case $1 in
    clean | CLEAN) clean=$1 ; shift ;;
    -f           ) force=$1 ; shift ;;
    g*           ) generate ; usage ;;
    h*           ) usage ;;
    *            ) break ;;
  esac
done

[ $1 ] && rules=$@
[ -e $rules ] || usage

clean() {
  ditto "vacuum $file"
  [ $clean ] || return
  case $clean in
    clean) sudo mv -v $file $vacuum ;;
    CLEAN) sudo rm -rvf $file ;;
  esac
}

# preserve stdin fd for package manager prompts
while read action file package <&3 ;do
  # echo "action=$action file=$file package=$package"
  case $action in
    '' |\
    '#') continue ;;

    '=') title "$file $package" ; continue ;;
    '!') ;;

    *  ) package=$file
         file=$action ;;
  esac

  [ -e $file ] || continue
  echo $file | grep -q "^\($HOME\)*[./]*$" && continue

  case $action in
    '!') clean ; continue ;;

    *  ) if [ $package ] ;then
           pacman -Qi $package >/dev/null || unset package
         elif [ $clean ] ;then
           if [ $force ] ;then
              package=true
           else
             ifno "remove $file" || package=true
           fi
         else
           ditto "remove ? $file"
           unset package
         fi ;;
  esac

  [ $package ] && clean
done 3< $rules

# vim: set ft=sh: #
